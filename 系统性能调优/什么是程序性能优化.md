# 什么是程序
程序只由两部分组成：**“命令” “数据”**

程序是：通过命令就是把原始的数据，整理成想要数据

比如：利用程序对数字“3 1 2” 进行排序，可以排成“1 2 3” 或者 “3 2 1”

# 程序性能优化
性能优化有2个大的方向：
1. 命令优化
2. 数据优化

## 什么是命令优化
### 存储式命令优化
比如现在对一个班的同学做信息统计，方便随后CRUD。

可使用各种数据结构来存储同学的信息，使用那种数据结构来存？

Array？Stack？Queue？Hash Table？B-Tree？

怎么选？
![数据结构_操作时间复杂度.jpg](0)
> 图片来自谷歌搜索

从上图总结结果来看(越绿，效果越好)，不考虑对学生做遍历和范围查询，选Hash Table来做学生的CRUD会是最好的选择

针对特定的数据选择合适的数据结构，这就是**命令优化之一**。

### 算法式命令优化
还是上面排序问题，当数据只有几时，使用肉眼就可以进行排序。

超过肉眼能力范围的就需要利用程序进行排序。现成的排序算法有很多种，那应该选哪个？

Quicksort？ Mergesort？ Timesort？ Heapsort？

![排序算法_时间复杂度.jpg](1)
> 图片来自谷歌搜索

从上图总结结果来看(越绿，效果越好)，选Counting Sort是最好的选择。但是现实中考虑的因素会不单单只是快慢，还是实现的复杂度，就单单针对上面提到的数字排序，还是用肉眼排序最快，都不用实现[手动狗头]。这也是**命令优化之一**。

命令优化的方向还有很多，后续再补充吧。

## 数据优化

这里的数据优化是指数据**缓存优化**。

会涉及多种类型的缓存，但大方向缓存的顺序是：

- CPU缓存是内存的缓存
- 内存是硬盘的缓存
- 硬盘是网络的缓存

这个过程中其实还有很多比较琐碎的小缓存，比如：

CPU一般会有三级缓存，分为：一级缓存、二级缓存、三级缓存，而它们也是顺序进行缓存(这个是硬件级缓存，不可修改大小)。

网卡上还会有网卡缓存、各程序之间也会有各自的缓存，而这些缓存是可以动态修改的。

而针对这些缓存的优化，其实本质是提高缓存命中率。通过提高命中率，来减少缓存之间的数据交换频率；实际中因为各个缓存之间的数据交换率太高，会减少程序的运行时间。

提高命中率很多时候会带来，运行时间几倍，甚至几十倍的差距。

### 例1，充分利用CPU缓存

这里是有一个专业的术语的**局部性原理**，有兴趣的可以用这个关键字去深入的了解一下。

局部性原理分为2部分：

时间局部性：被使用过的数据地址被多次使用(常见循环中)
空间局部性：当数据被使用，那它附近的数据也会被使用












